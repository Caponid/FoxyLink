// This file is part of Update.Express.
// Copyright © 2016 Petro Bazeliuk.
// 
// Update.Express is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as 
// published by the Free Software Foundation, either version 3 
// of the License, or any later version.
// 
// Update.Express is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public 
// License along with Update.Express. If not, see <http://www.gnu.org/licenses/>.

#Область ПрограммныйИнтерфейс

// Выводит результат схемы компоновки данных в JSON поток.
//
// Параметры:
//	ЗаписьJSON		- ЗаписьJSON - объект предназначен для организации последовательной записи объектов и текстов JSON.
//	ПараметрыВывода - Структура  - параметры макета компоновки данных.
//		* ВнешниеНаборыДанных - Структура - ключ структуры соответствует имени внешнего набора данных. 
//                              Значение структуры - внешнему набору данных. 
//		* ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных - объект, в котором нужно заполнить данные расшифровки.
//                            Если не указан, то расшифровка заполняться не будет. 
//		* ВозможностьИспользованияВнешнихФункций - Булево - указывает возможность использования функции общих модулей
//                                                 конфигурации в выражениях компоновки данных.
//                                                 Значение по умолчанию: 
//													 Ложь.
//		* ПараметрыМакета - Структура - структура параметров необходимых для создания макета компоновки данных.
//			** Схема - СхемаКомпоновкиДанных - схема, для которой требуется построить макет. 
//			** Настройки - НастройкиКомпоновкиДанных - настройки, для которых необходимо создать макет. 
//			** ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных - содержит переменную, в которую будут помещены данные
//        				      расшифровки. Если параметр не указан, расшифровка заполняться не будет.
//			** МакетОформления - МакетОформленияКомпоновкиДанных - макет оформления, в соответствии с которым необходимо 
//                          оформлять макет компоновки данных. Если не указан, будет использоваться макет оформления 
//                          по умолчанию. 
//			** ТипГенератора - Тип - указывает тип генератора макета компоновки данных.			  
//					  Возможные типы: 
//                    	ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений; 
//                      ГенераторМакетаКомпоновкиДанных.               
//					  Значение по умолчанию: 
//						Тип("ГенераторМакетаКомпоновкиДанных"). 
//			** ПроверятьДоступностьПолей - Булево - определяет, выполнять ли проверку прав на просмотр полей и проверку 
//                                    доступности поля во включенных функциональных возможностях.
//			** ПараметрыФункциональныхОпций - Структура - содержит параметры функциональных опций, используемые при 
//                                       исполнении отчета.
//	ВозможностьПрерыванияПользователем - Булево - указывает, может ли пользователь прервать вывод при помощи комбинации
//										 клавиш Ctrl + Break.
//										 Значение по умолчанию: 
//										   Ложь.
//	ЭкономитьРесурсы 				   - Булево - использовать последовательный вывод без привлечения дополнительных 
//										 объектов для вывода в JSON поток.
//                                       Значение по умолчанию: 
//										   Ложь.
//
Процедура Вывести(ЗаписьJSON, ПараметрыВывода, ЭкономитьРесурсы = Ложь, 
	ВозможностьПрерыванияПользователем = Ложь) Экспорт
	
	
	// TODO: Проверка параметров вывода
	
	
	ПараметрыМакета = UpdateExpressСлужебныйКлиентСервер.СкопироватьСтруктуру(
		ПараметрыВывода.ПараметрыМакета);
		
	// Убедимся, что действительно верный тип генератора будет использован
	ПараметрыМакета.ТипГенератора = 
		Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений");		
	МакетКомпоновкиДанных = UpdateExpressКомпоновкаДанных
		.СоздатьМакетКомпоновкиДанных(ПараметрыМакета);
					
	// Инициализация процессора компоновки данных
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновкиДанных, 
		ПараметрыВывода.ВнешниеНаборыДанных, 
		ПараметрыВывода.ДанныеРасшифровки, 
		ПараметрыВывода.ВозможностьИспользованияВнешнихФункций);
		
		
	// Инициализация колонок макетов и настроек макетов
	КэшКолонокМакетов = СоздатьКэшКолонокМакетов(ПараметрыМакета.Настройки,
		МакетКомпоновкиДанных, МакетКомпоновкиДанных.Тело);
		
	КэшНастроекМакетов = СоздатьКэшНастроекМакетов(МакетКомпоновкиДанных, 
		МакетКомпоновкиДанных.Тело);
	
	
	// Начать вывод элементов из процессора компоновки данных
	ПроцессорКомпоновкиДанных.Следующий(); // НачальныйЭлемент	
	ПроцессорКомпоновкиДанных.Следующий(); // МакетКомпоновкиДанных	
	Элемент = ПроцессорКомпоновкиДанных.Следующий(); // Выполнение запроса 
	
	Если ЭкономитьРесурсы = Истина Тогда
	
		ВывестиСЭкономиейПамяти(ЗаписьJSON, 
			Элемент,
			ПроцессорКомпоновкиДанных,
			КэшКолонокМакетов,
			КэшНастроекМакетов);
			
	Иначе
			
		ВывестиБезЭкономииПамяти(ЗаписьJSON, 
			Элемент,
			ПроцессорКомпоновкиДанных,
			КэшКолонокМакетов,
			КэшНастроекМакетов);		
			
	КонецЕсли;
					
КонецПроцедуры // Вывести()
 
#КонецОбласти // ПрограммныйИнтерфейс

#Область СервисныеПроцедурыИФункции

// Выводит последлвательно результат схемы компоновки данных в JSON поток. 
// 
// Параметры:
//	ЗаписьJSON 				  - ЗаписьJSON - объект предназначен для организации последовательной записи объектов и текстов JSON.
//	Элемент	   				  - ЭлементРезультатаКомпоновкиДанных - элемент результата компоновки данных. Используется потому, что 
//								перед вызовом процедуры выполняеться замер выполнениия схемы компоновки данных.
//	ПроцессорКомпоновкиДанных - ПроцессорКомпоновкиДанных - объект, выполняющий компоновку данных.
//	КэшКолонокМакетов		  - Соответствие - кэш колонок вложенных макетов компоновки данных.
//		* Ключ 	   - Строка - имя вложенного макета компоновки данных, которому соответствует массив структур.
//					 Структуры в массиве описывают имена свойств для вывода в JSON поток, а так же
//					 хранят путь к значению свойства JSON в объекте "ЭлементРезультатаКомпоновкиДанных".
//		* Значение - Массив - массив структур с правильным порядком колонок, что в свою очередь, 
//					 обеспечивает аналогичный порядок вывода как в табличном документе. 
//			** ЭлементМассива - Структура - содержит имя свойства для вывода в JSON поток и путь к 
//								значению свойства JSON в объекте "ЭлементРезультатаКомпоновкиДанных". 
//				*** Имя  - Строка - описывает имя свойства для вывода в JSON поток. 
//				*** Ключ - Строка - хранит путь к значению свойства JSON в объекте 
//						   "ЭлементРезультатаКомпоновкиДанных".
//	КэшНастроекМакетов		  - Соответствие - кэш настроек вложенных макетов компоновки данны.
//		* Ключ 	   - Строка - имя вложенного макета компоновки данных которому соответствует кэш настроек.
//		* Значение - Строка - имя элемента тела вложенного макета компоновки данных, которое будет использовано,
//					 как описание массива для вывода в JSON поток.
//
Процедура ВывестиСЭкономиейПамяти(ЗаписьJSON, Элемент, ПроцессорКомпоновкиДанных, 
	КэшКолонокМакетов, КэшНастроекМакетов)
	
	Уровень = Неопределено;
	Конец = ТипЭлементаРезультатаКомпоновкиДанных.Конец;
	Начало = ТипЭлементаРезультатаКомпоновкиДанных.Начало;
	НачалоИКонец = ТипЭлементаРезультатаКомпоновкиДанных.НачалоИКонец;	
	Пока Истина Цикл
				
		Если Элемент = Неопределено Тогда
			Прервать;
		КонецЕсли;	
		
		Если Элемент.ТипЭлемента = Начало Тогда
			
			Элемент = ПроцессорКомпоновкиДанных.Следующий();		
			Если Элемент.ТипЭлемента = Начало Тогда
				
				Элемент = ПроцессорКомпоновкиДанных.Следующий();
				Если Элемент.ТипЭлемента = НачалоИКонец Тогда
					
					// Для сложной иерархии работает быстрее
					Уровень = ?(Уровень = Неопределено, 0, Уровень + 1);
					
					ЗаписьJSON.ЗаписатьИмяСвойства(КэшНастроекМакетов[Элемент.Макет]);
					ЗаписьJSON.ЗаписатьНачалоМассива();
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если Уровень <> Неопределено Тогда
			
			Если Элемент.ТипЭлемента = Конец Тогда
				
				ЗаписьJSON.ЗаписатьКонецОбъекта();
				
				Элемент = ПроцессорКомпоновкиДанных.Следующий();
				Если Элемент.ТипЭлемента = Конец Тогда
										
					// Для сложной иерархии работает быстрее
					Уровень = ?(Уровень - 1 < 0, Неопределено, Уровень - 1);

					ЗаписьJSON.ЗаписатьКонецМассива();
															
				//ИначеЕсли НЕ ПустаяСтрока(Элемент.Макет) Тогда
					
					// Вход в это условие невозможен из-за структуры вывода
					// процессора компоновки данных	
					
				КонецЕсли;
				
			ИначеЕсли НЕ ПустаяСтрока(Элемент.Макет) Тогда
				
				Колонки = КэшКолонокМакетов[Элемент.Макет];
				
				ЗаписьJSON.ЗаписатьНачалоОбъекта();
				Для Каждого Колонка Из Колонки Цикл
	 				ЗаписьJSON.ЗаписатьИмяСвойства(Колонка.Имя);
					ЗаписатьJSON(ЗаписьJSON,
						Элемент.ЗначенияПараметров[Колонка.Ключ].Значение,
						,
						"ФункцияПреобразования",
						UpdateExpressПроцессорВыводаПовтИсп);
				КонецЦикла;	
				
			КонецЕсли;
			
		КонецЕсли;
		
		Элемент = ПроцессорКомпоновкиДанных.Следующий();
					
	КонецЦикла;
	
КонецПроцедуры // ВывестиСЭкономиейПамяти()

// Выводит результат схемы компоновки данных в JSON поток с использованием дополнительных объектов для ускорения вывода на 20%. 
// 
// Параметры:
//	ЗаписьJSON 				  - ЗаписьJSON - объект предназначен для организации последовательной записи объектов и текстов JSON.
//	Элемент	   				  - ЭлементРезультатаКомпоновкиДанных - элемент результата компоновки данных. Используется потому, что 
//								перед вызовом процедуры выполняеться замер выполнениия схемы компоновки данных.
//	ПроцессорКомпоновкиДанных - ПроцессорКомпоновкиДанных - объект, выполняющий компоновку данных.
//	КэшКолонокМакетов		  - Соответствие - кэш колонок вложенных макетов компоновки данных.
//		* Ключ 	   - Строка - имя вложенного макета компоновки данных, которому соответствует массив структур.
//					 Структуры в массиве описывают имена свойств для вывода в JSON поток, а так же
//					 хранят путь к значению свойства JSON в объекте "ЭлементРезультатаКомпоновкиДанных".
//		* Значение - Массив - массив структур с правильным порядком колонок, что в свою очередь, 
//					 обеспечивает аналогичный порядок вывода как в табличном документе. 
//			** ЭлементМассива - Структура - содержит имя свойства для вывода в JSON поток и путь к 
//								значению свойства JSON в объекте "ЭлементРезультатаКомпоновкиДанных". 
//				*** Имя  - Строка - описывает имя свойства для вывода в JSON поток. 
//				*** Ключ - Строка - хранит путь к значению свойства JSON в объекте 
//						   "ЭлементРезультатаКомпоновкиДанных".
//	КэшНастроекМакетов		  - Соответствие - кэш настроек вложенных макетов компоновки данны.
//		* Ключ 	   - Строка - имя вложенного макета компоновки данных которому соответствует кэш настроек.
//		* Значение - Строка - имя элемента тела вложенного макета компоновки данных, которое будет использовано,
//					 как описание массива для вывода в JSON поток.
//
Процедура ВывестиБезЭкономииПамяти(ЗаписьJSON, Элемент, ПроцессорКомпоновкиДанных, 
	КэшКолонокМакетов, КэшНастроекМакетов)
	
	КэшКлючей = СоздатьКэшКлючейМакетов(КэшКолонокМакетов);
	
	СтруктураВывода = Новый Структура;
	
	ДеревоВывода = Новый ДеревоЗначений;
	ДеревоВывода.Колонки.Добавить("Массив");
	ДеревоВывода.Колонки.Добавить("Структура");
	
	ТекущаяСтрока = Неопределено;	
	Конец = ТипЭлементаРезультатаКомпоновкиДанных.Конец;
	Начало = ТипЭлементаРезультатаКомпоновкиДанных.Начало;
	НачалоИКонец = ТипЭлементаРезультатаКомпоновкиДанных.НачалоИКонец;
	Пока Истина Цикл
				
		Если Элемент = Неопределено Тогда
			Прервать;
		КонецЕсли;	
		
		Если Элемент.ТипЭлемента = Начало Тогда
			
			Элемент = ПроцессорКомпоновкиДанных.Следующий();		
			Если Элемент.ТипЭлемента = Начало Тогда
				
				Элемент = ПроцессорКомпоновкиДанных.Следующий();
				Если Элемент.ТипЭлемента = НачалоИКонец Тогда
					
					Массив = Новый Массив;
					
					Если ТекущаяСтрока = Неопределено Тогда
						
						СтруктураВывода.Вставить(КэшНастроекМакетов[Элемент.Макет], Массив);
						ТекущаяСтрока = ДеревоВывода.Строки.Добавить();
						
					Иначе
						
						ТекущаяСтрока.Структура.Вставить(КэшНастроекМакетов[Элемент.Макет], Массив);
						ТекущаяСтрока = ТекущаяСтрока.Строки.Добавить();
								
					КонецЕсли;
					
					ТекущаяСтрока.Массив = Массив;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ТекущаяСтрока <> Неопределено Тогда
			
			Если Элемент.ТипЭлемента = Конец Тогда
				
				ТекущаяСтрока = ТекущаяСтрока.Родитель;
				
				Элемент = ПроцессорКомпоновкиДанных.Следующий();
				Если Элемент.ТипЭлемента = Конец Тогда
															
					ТекущаяСтрока = ТекущаяСтрока.Родитель;
															
				//ИначеЕсли НЕ ПустаяСтрока(Элемент.Макет) Тогда
					
					// Вход в это условие невозможен из-за структуры вывода
					// процессора компоновки данных	
					
				КонецЕсли;
				
			ИначеЕсли НЕ ПустаяСтрока(Элемент.Макет) Тогда
				
				Колонки = КэшКолонокМакетов[Элемент.Макет];
				Структура = Новый Структура(КэшКлючей[Элемент.Макет]);
				ТекущаяСтрока.Массив.Добавить(Структура);
				
				ТекущаяСтрока = ТекущаяСтрока.Строки.Добавить();
				ТекущаяСтрока.Структура = Структура;
				
				Для Каждого Колонка Из Колонки Цикл
					//Структура.Вставить(Колонка.Имя); //, Элемент.ЗначенияПараметров[Колонка.Ключ].Значение);
					Структура[Колонка.Имя] = Элемент.ЗначенияПараметров[Колонка.Ключ].Значение;
				КонецЦикла;	
				
			КонецЕсли;
			
		КонецЕсли;
		
		Элемент = ПроцессорКомпоновкиДанных.Следующий();
					
	КонецЦикла;
	
	Для Каждого ЭлементСтруктуры Из СтруктураВывода Цикл
		
		ЗаписьJSON.ЗаписатьИмяСвойства(ЭлементСтруктуры.Ключ);
		ЗаписатьJSON(ЗаписьJSON,
			ЭлементСтруктуры.Значение,
			,
			"ФункцияПреобразования",
			UpdateExpressПроцессорВыводаПовтИсп);
		
	КонецЦикла;
	
КонецПроцедуры // ВывестиБезЭкономииПамяти()

// Заполняет кэш ресурсов схемы компоновки данных.
//
// Параметры:
//	Элементы	- КоллекцияДоступныхПолейКомпоновкиДанных - доступные поля компоновки данных.
//	КэшРесурсов - Соответствие - кэш в который будут помещены все ресурсы компоновки данных.
//		* Ключ 	   - Строка - нормализованное имя колонки, которое соответствует имени
//                   свойства для вывода в JSON поток, а так же имени в табличном документе.
//		* Значение - Булево - Истина, если это ресурс; Ложь - в противном случае.
//
Процедура ЗаполнитьКэшРесурсов(Элементы, КэшРесурсов)

	Для Каждого Элемент Из Элементы Цикл
		
		Если Элемент.Ресурс Тогда
			ИмяКолонки = Строка(Элемент.Поле);
			КэшРесурсов.Вставить(НормализироватьИмяКолонки(ИмяКолонки), Истина);
		КонецЕсли;
		
		Если Элемент.Таблица Тогда
			ЗаполнитьКэшРесурсов(Элемент.Элементы, КэшРесурсов);
		КонецЕсли;

	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьКэшРесурсов()


// Создает строковой кэш ключей для инициализации структуры по "Ключам и значениям". 
//
// Параметры:
// 	КэшКолонокМакетов - Соответствие - кэш колонок вложенных макетов компоновки данных.
//		* Ключ 	   - Строка - имя вложенного макета компоновки данных, которому соответствует массив структур.
//					 Структуры в массиве описывают имена свойств для вывода в JSON поток, а так же
//					 хранят путь к значению свойства JSON в объекте "ЭлементРезультатаКомпоновкиДанных".
//		* Значение - Массив - массив структур с правильным порядком колонок, что в свою очередь, 
//					 обеспечивает аналогичный порядок вывода как в табличном документе. 
//			** ЭлементМассива - Структура - содержит имя свойства для вывода в JSON поток и путь к 
//								значению свойства JSON в объекте "ЭлементРезультатаКомпоновкиДанных". 
//				*** Имя  - Строка - описывает имя свойства для вывода в JSON поток. 
//				*** Ключ - Строка - хранит путь к значению свойства JSON в объекте 
//						   "ЭлементРезультатаКомпоновкиДанных".
//
// Возвращаемое значение:
//	Соответствие - строковой кэш ключей структуры.
//		* Ключ 	   - Строка - имя вложенного макета компоновки данных, которому соответствуют ключи.
//		* Значение - Строка - ключи для инициализации структуры по "Ключам и значениям".
//
Функция СоздатьКэшКлючейМакетов(КэшКолонокМакетов)
	
	КэшКлючей = Новый Соответствие;	
	Для Каждого Элемент Из КэшКолонокМакетов Цикл
		КэшКлючей.Вставить(Элемент.Ключ, 
			UpdateExpressСлужебныйКлиентСервер.КоллекцияКолонокВСтроку(Элемент.Значение));	
		КонецЦикла;
		
	Возврат КэшКлючей;
	
КонецФункции // СоздатьКэшКлючейМакетов()
	
// Рекурсивно создает кэш колонок для вложенных макетов комповноки данных в основной макет компоновки данных. 
//
// Параметры:
// 	НастройкиКомпоновкиДанных - НастройкиКомпоновкиДанных  - настройки компоновки данных используются для создания
//								кэша ресурсов который необходим для вывода ресурсов по группировкам.
//	МакетКомпоновкиДанных	  - МакетКомпоновкиДанных	   - основной макет компоновки данных для которого 
//								необходимо создать кэш колонок вложенных макетов компоновки данных.
//	МакетКомпоновкиДанныхТело - ТелоМакетаКомпоновкиДанных - тело текущего макета компоновки данных. Используется
//								для вычисления иерархии и типов элементов макетов компоновки данных.
//	КэшКолонок				  - Соответствие, Неопределено - кэш колонок вложенных макетов компоновки данных.
//		* Ключ 	   - Строка 	  - имя вложенного макета компоновки данных которому соответствует вложенный кэш колонок.
//					 Используется потому, что каждый вложенный макет может иметь свой порядок колонок и группировок.
//		* Значение - Соответствие - кэш колонок вложенного макета компоновки данных.
//			** Ключ 	- Строка - строковое значение ячейки вложенного макета компоновки данных вида: П1, П2, ..., Пn.
//			** Значение - Строка - нормализованное имя колонки, которое соответствует имени
//                        свойства для вывода в JSON поток.
//  КэшРесурсов				  - Соответствие, Неопределено - кэш который содержит все ресурсы компоновки данных.
//		* Ключ 	   - Строка - нормализованное имя колонки, которое соответствует имени
//                   свойства для вывода в JSON поток.
//		* Значение - Булево - Истина, если это ресурс; Ложь - в противном случае.
//	КэшКолонокМакетов		  - Соответствие, Неопределено - кэш колонок вложенных макетов компоновки данных.
//		* Ключ 	   - Строка - имя вложенного макета компоновки данных, которому соответствует массив структур.
//					 Структуры в массиве описывают имена свойств для вывода в JSON поток, а так же
//					 хранят путь к значению свойства JSON в объекте "ЭлементРезультатаКомпоновкиДанных".
//		* Значение - Массив - массив структур с правильным порядком колонок, что в свою очередь, 
//					 обеспечивает аналогичный порядок вывода как в табличном документе. 
//			** ЭлементМассива - Структура - содержит имя свойства для вывода в JSON поток и путь к 
//								значению свойства JSON в объекте "ЭлементРезультатаКомпоновкиДанных". 
//				*** Имя  - Строка - описывает имя свойства для вывода в JSON поток. 
//				*** Ключ - Строка - хранит путь к значению свойства JSON в объекте 
//						   "ЭлементРезультатаКомпоновкиДанных". 
//	КолонокиНаУдаление		  - Соответствие, Неопределено - колонки которые необходимо удалить, если опускаемся вниз 
//								по иерархии и в объекте "МакетКомпоновкиДанныхТело" имеются элементы с типом 
//								"ГруппировкаМакетаКомпоновкиДанных". Обеспечивает соответствие вывода как в табличном 
//								документе с группировками.
//		* Ключ 	   - Строка - строковое значение ячейки вложенного макета компоновки данных вида: П1, П2, ..., Пn.
//		* Значение - Строка - выражение, по которому вычисляется значение параметра области компоновки данных.
//
// Возвращаемое значение:
//	Соответствие - кэш колонок вложенных макетов компоновки данных.
//		* Ключ 	   - Строка - имя вложенного макета компоновки данных, которому соответствует массив структур.
//					 Структуры в массиве описывают имена свойств для вывода в JSON поток, а так же
//					 хранят путь к значению свойства JSON в объекте "ЭлементРезультатаКомпоновкиДанных".
//		* Значение - Массив - массив структур с правильным порядком колонок, что в свою очередь, 
//					 обеспечивает аналогичный порядок вывода как в табличном документе. 
//			** ЭлементМассива - Структура - содержит имя свойства для вывода в JSON поток и путь к 
//								значению свойства JSON в объекте "ЭлементРезультатаКомпоновкиДанных". 
//				*** Имя  - Строка - описывает имя свойства для вывода в JSON поток. 
//				*** Ключ - Строка - хранит путь к значению свойства JSON в объекте 
//						   "ЭлементРезультатаКомпоновкиДанных".
//
Функция СоздатьКэшКолонокМакетов(НастройкиКомпоновкиДанных,
	МакетКомпоновкиДанных, 
	МакетКомпоновкиДанныхТело, 
	КэшКолонок = Неопределено,
	КэшРесурсов = Неопределено,
	КэшКолонокМакетов = Неопределено,
	КолонокиНаУдаление = Неопределено)
	
	Если КэшКолонок = Неопределено 
	  И  КэшРесурсов = Неопределено
	  И  КэшКолонокМакетов = Неопределено 
	  И  КолонокиНаУдаление = Неопределено Тогда
	  
		КэшКолонок = СоздатьКэшКолонок(МакетКомпоновкиДанных);
		
		КэшРесурсов = Новый Соответствие;
		Элементы = НастройкиКомпоновкиДанных.Выбор.ДоступныеПоляВыбора.Элементы;
		ЗаполнитьКэшРесурсов(Элементы, КэшРесурсов);
		
		КэшКолонокМакетов = Новый Соответствие;
		КолонокиНаУдаление = Новый Соответствие;
		
	КонецЕсли;
		
	Для Каждого ЭлементТела Из МакетКомпоновкиДанныхТело Цикл
		
		Если ТипЗнч(ЭлементТела) = Тип("МакетОбластиМакетаКомпоновкиДанных") Тогда
			Продолжить;	
		КонецЕсли;
		
		КэшПорядокКолонок = Новый Массив;
		ОписаниеМакетаОбласти = ОписаниеМакетОбласти(МакетКомпоновкиДанных, 
			ЭлементТела);
			
		КолонкиНаУдалениеИерархия = Новый Соответствие;
		Для Каждого Ячейка Из ОписаниеМакетаОбласти.Макет.Ячейки Цикл
				
			Если Ячейка.Значение = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Ключ = Строка(Ячейка.Значение);
			ПараметрОбластиВыражение = ПараметрОбластиВыражение(
				ОписаниеМакетаОбласти.Параметры, Ключ);
				
			Выражение = ПараметрОбластиВыражение.Выражение;
			
			Если ТипЗнч(ЭлементТела) = Тип("ГруппировкаМакетаКомпоновкиДанных") Тогда
				
				КолонкаНаУдаление = КолонокиНаУдаление[Ключ];
				Если КолонкаНаУдаление = Неопределено Тогда
					Результат = ЭлементГруппировкиМакета(
						ЭлементТела.Группировка, 
						Выражение,
						Истина);	
				Иначе
					Результат = ЭлементГруппировкиМакета(
						ЭлементТела.Группировка, 
						Выражение,
						Ложь);		
				КонецЕсли;
				
				//Если КэшРесурсов
				
				Если Результат = Неопределено Тогда
					//Если НЕ UpdateExpressПроцессорВыводаПовтИсп.ЭтоПолеРесурс(Выражение) Тогда
					//	Продолжить;
					//КонецЕсли;
					Если КэшРесурсов[КэшКолонок[ОписаниеМакетаОбласти.Имя][Ключ]] = Неопределено Тогда
						Продолжить;	
					КонецЕсли;
					
					
				Иначе
					КолонкиНаУдалениеИерархия.Вставить(Ключ, Выражение);	
				КонецЕсли;
					
			ИначеЕсли ТипЗнч(ЭлементТела) = Тип("ЗаписиМакетаКомпоновкиДанных") Тогда
				
				КолонкаНаУдаление = КолонокиНаУдаление[Ключ];
				Если КолонкаНаУдаление <> Неопределено Тогда
					Продолжить;	
				КонецЕсли;
				
			КонецЕсли;
			
			КлючИКолонка = Новый Структура;
			КлючИКолонка.Вставить("Ключ", Ключ);
			КлючИКолонка.Вставить("Имя", КэшКолонок[ОписаниеМакетаОбласти.Имя][Ключ]);
			КэшПорядокКолонок.Добавить(КлючИКолонка);
			
		КонецЦикла;
		
		КэшКолонокМакетов.Вставить(ОписаниеМакетаОбласти.Имя, 
			КэшПорядокКолонок);
		
		
		Если ЭлементТела.Тело.Количество() > 1 Тогда
						
			Для Каждого Колонка Из КолонокиНаУдаление Цикл
				КолонкиНаУдалениеИерархия.Вставить(Колонка.Ключ, Колонка.Значение);		
			КонецЦикла;
			
			СоздатьКэшКолонокМакетов(НастройкиКомпоновкиДанных,
				МакетКомпоновкиДанных, 
				ЭлементТела.Тело,
				КэшКолонок,
				КэшРесурсов,
				КэшКолонокМакетов,
				КолонкиНаУдалениеИерархия);		
			
		КонецЕсли;
			
	КонецЦикла;
		
	Возврат КэшКолонокМакетов;
	
КонецФункции // СоздатьКэшКолонокМакетов()

// Рекурсивно создает кэш настроек вложенных макетов компоновки данных в основной макет компоновки данных.
//
// Параметры:
//	МакетКомпоновкиДанных     - МакетКомпоновкиДанных      - основной макет компоновки данных для которого 
//								необходимо создать кэш настроек вложенных макетов компоновки данных. 
//	МакетКомпоновкиДанныхТело - ТелоМакетаКомпоновкиДанных - тело текущего макета компоновки данных. 
//  КэшНастроекМакетов		  - Соответствие, Неопределено - кэш настроек вложенных макетов компоновки данны.
//		* Ключ 	   - Строка - имя вложенного макета компоновки данных которому соответствует кэш настроек.
//		* Значение - Строка - имя элемента тела вложенного макета компоновки данных, которое будет использовано,
//					 как описание массива для вывода в JSON поток.
//
// Возвращаемое значение:
//  Соответствие - кэш настроек вложенных макетов компоновки данны.
//		* Ключ 	   - Строка - имя вложенного макета компоновки данных которому соответствует кэш настроек.
//		* Значение - Строка - имя элемента тела вложенного макета компоновки данных, которое будет использовано,
//					 как описание массива для вывода в JSON поток.
//
Функция СоздатьКэшНастроекМакетов(МакетКомпоновкиДанных,
	МакетКомпоновкиДанныхТело, 
	КэшНастроекМакетов = Неопределено)
	
	Если КэшНастроекМакетов = Неопределено Тогда
		КэшНастроекМакетов = Новый Соответствие;	
	КонецЕсли;
	
	Для Каждого ЭлементТела Из МакетКомпоновкиДанныхТело Цикл
		
		Если ТипЗнч(ЭлементТела) = Тип("МакетОбластиМакетаКомпоновкиДанных") Тогда
			Продолжить;	
		КонецЕсли;
		
		ОписаниеМакетаОбласти = ОписаниеМакетОбласти(МакетКомпоновкиДанных, 
			ЭлементТела);
			
		КэшНастроекМакетов.Вставить(ОписаниеМакетаОбласти.Имя, 
			ЭлементТела.Имя);
			
		Если ЭлементТела.Тело.Количество() > 1 Тогда
			СоздатьКэшНастроекМакетов(МакетКомпоновкиДанных, 
				ЭлементТела.Тело,
				КэшНастроекМакетов);		
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат КэшНастроекМакетов;
	
КонецФункции // СоздатьКэшНастроекМакетов()

// Создает кэш колонок для вложенных макетов компоновки данных из которых состоит основной макет компоновки данных.
//
// Параметры:
//	МакетКомпоновкиДанных - МакетКомпоновкиДанных - основной макет компоновки данных из которого необходимо создать кэш.
//
// Возвращаемое значение:
//	Соответствие - кэш колонок вложенных макетов компоновки данных.
//		* Ключ 	   - Строка 	  - имя вложенного макета компоновки данных которому соответствует 
//					 вложенный кэш колонок. Используется потому, что каждый вложенный макет может 
//					 иметь свой порядок колонок и группировок.
//		* Значение - Соответствие - кэш колонок вложенного макета компоновки данных.
//			** Ключ 	- Строка - строковое значение ячейки вложенного макета компоновки данных 
//						  вида: П1, П2, ..., Пn.
//			** Значение - Строка - нормализованное имя колонки, которое соответствует имени свойства 
//						  для вывода в JSON поток. 
//
Функция СоздатьКэшКолонок(МакетКомпоновкиДанных)
	
	КэшКолонок = Новый Соответствие;
	ОсновнойМакет = МакетКомпоновкиДанных.Макеты.Найти("Макет1");
	Если ОсновнойМакет = Неопределено Тогда
		Возврат КэшКолонок;	
	КонецЕсли;
	
	ЯчейкиОсновногоМакета = ОсновнойМакет.Макет.Ячейки;
	Для Каждого Макет Из МакетКомпоновкиДанных.Макеты Цикл
		
		Если Макет = ОсновнойМакет Тогда
			Продолжить;	
		КонецЕсли;
		
		КэшКолонокПоМакету = Новый Соответствие; 
		Ячейки = Макет.Макет.Ячейки;
		Для Индекс = 0 По Ячейки.Количество() - 1 Цикл
			
			Ячейка = Ячейки[Индекс];
			Если Ячейка.Значение = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			
			Если ПустаяСтрока(Ячейка.Колонка) Тогда
				Значение = НормализироватьИмяКолонки(ЯчейкиОсновногоМакета[Индекс].Имя);	
			Иначе
				Значение = НормализироватьИмяКолонки(Ячейка.Колонка); 	
			КонецЕсли;
			
			КэшКолонокПоМакету.Вставить(Строка(Ячейка.Значение), Значение); 
				
		КонецЦикла;
		
		КэшКолонок.Вставить(Макет.Имя, КэшКолонокПоМакету);
	
	КонецЦикла;
	
	Возврат КэшКолонок; 
	
КонецФункции // СоздатьКэшКолонок() 

// Возвращает описание макета области макета компоновки данных, которое соответствует элементу тела. Используется
// для реализации механизма обхода ячеек вложенных макетов компоновки данных.
//
// Параметры:
//	МакетКомпоновкиДанных - МакетКомпоновкиДанных - основной макет компоновки данных/ 
//	ЭлементТела			  - ГруппировкаМакетаКомпоновкиДанных, ДиаграммаМакетаКомпоновкиДанных,
//                          ИерархическаяГруппировкаТаблицыМакетаКомпоновкиДанных,
//	                        ЗаписиМакетаКомпоновкиДанных, ТаблицаМакетаКомпоновкиДанных,
//							ВложенныйОбъектМакетаКомпоновкиДанных - Элемент тела макета компоновки данных. 
//												  
// Возвращаемое значение:
//	ОписаниеМакетаОбластиМакетаКомпоновкиДанных - описание макета области.
//
Функция ОписаниеМакетОбласти(МакетКомпоновкиДанных, ЭлементТела)
	
	Если ЭлементТела.Тело.Количество() = 0 Тогда
		СообщениеОбОшибке = НСтр(
			"en = '""DataCompositionTemplateAreaTemplate"" is not found!'; 
			|ru = '""МакетОбластиМакетаКомпоновкиДанных"" не найден!'; 
			|uk = '""МакетОбластиМакетаКомпоновкиДанных"" не знайдено!'");
		ВызватьИсключение СообщениеОбОшибке;
	КонецЕсли;
	
	МакетОбласти = ЭлементТела.Тело[0];
	Если ТипЗнч(МакетОбласти) <> Тип("МакетОбластиМакетаКомпоновкиДанных") Тогда
		СообщениеОбОшибке = НСтр(
			"en = 'The body does not contain ""DataCompositionTemplateAreaTemplate""!'; 
			|ru = 'Тело не содержит ""МакетОбластиМакетаКомпоновкиДанных""!'; 
			|uk = 'Тіло не містить ""МакетОбластиМакетаКомпоновкиДанных""!'");
		ВызватьИсключение СообщениеОбОшибке;	
	КонецЕсли;
	
	РезультатПоиска = МакетКомпоновкиДанных.Макеты.Найти(МакетОбласти.Макет);
	Если РезультатПоиска = Неопределено Тогда
		СообщениеОбОшибке = НСтр(
			"en = '""DataCompositionTemplateAreaTemplateDefinition"" is not found!'; 
			|ru = '""ОписаниеМакетаОбластиМакетаКомпоновкиДанных"" не найден!'; 
			|uk = '""ОписаниеМакетаОбластиМакетаКомпоновкиДанных"" не знайдено!'");
		ВызватьИсключение СообщениеОбОшибке;		
	КонецЕсли;
	
	Возврат РезультатПоиска; 
	
КонецФункции // ОписаниеМакетОбласти()

// Возвращает описание параметра области вложенного макета компоновки данных. Используется для обеспечения 
// аналогичного вывода как в табличном документе при наличии группировок.
//
// Параметры:
//	Параметры	 - ПараметрыОбластиКомпоновкиДанных - параметры области вложенного макета компоновки данных. 
//	ИмяПараметра - Строка							- имя параметра которое нобходимо найти.
//
// Возвращаемое значение:
//	ПараметрОбластиВыражениеКомпоновкиДанных, ПараметрОбластиРасшифровкаКомпоновкиДанных - описание параметра макета
//	области или расшифровка соответственно.
//
Функция ПараметрОбластиВыражение(Параметры, ИмяПараметра)
	
	РезультатПоиска = Параметры.Найти(ИмяПараметра);
	Если РезультатПоиска = Неопределено Тогда
		СообщениеОбОшибке = НСтр(
			"en = '""DataCompositionExpressionAreaParameter"" is not found!'; 
			|ru = '""ПараметрОбластиВыражениеКомпоновкиДанных"" не найден!'; 
			|uk = '""ПараметрОбластиВыражениеКомпоновкиДанных"" не знайдено!'");
		ВызватьИсключение СообщениеОбОшибке;		
	КонецЕсли;
	
	Возврат РезультатПоиска;
	
КонецФункции // ПараметрОбластиВыражение()

// Возвращает элемент группировки по выражению элемента группировки, если он был найден.
//
// Параметры:
// 	ГруппировкиМакета 		- ГруппировкиМакетаКомпоновкиДанных - группировки макета компоновки данных из элемента
//							  тела макета компоновки данных с типом "ГруппировкаМакетаКомпоновкиДанных".
//	Выражение		  		- Строка 							- выражение элемента группировка.
//	ОбрабатыватьПодчиненные - Булево 							- если это верх иерархии, то в табличном документе 
//							  поля, которые получаются из данной группировки, так же будут выведены на этом уровне.
//							  Если это подчиненная группировка и поля имеют пересечения с родительской группировкой
//							  необходимо удалить все родительские поля которые были получены косвенным образом. 
//
// Возвращаемое значение:
//	ГруппировкиМакетаКомпоновкиДанных, Неопределено - найденный элемент группировки по выражению; Неопределено - если
//	элемент был не найден.		
//
Функция ЭлементГруппировкиМакета(ГруппировкиМакета, Выражение, 
	ОбрабатыватьПодчиненные = Истина)
	
	Для Каждого ГруппировкаМакета Из ГруппировкиМакета Цикл
		
		Если ГруппировкаМакета.Выражение = Выражение Тогда
			Возврат ГруппировкаМакета;	
		КонецЕсли;
		
		Если ОбрабатыватьПодчиненные Тогда
			
			ПодчиненныеДанные = ГруппировкаМакета.Выражение + ".";
			// 8.3.6+
			//Позиция = СтрНайти(Значение, ПодчиненныеДанные);
			Позиция = Найти(Выражение, ПодчиненныеДанные);
			Если Позиция = 1 Тогда
				Возврат ГруппировкаМакета;	
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // ЭлементГруппировкиМакета()

// Возвращает нормализированное имя колонки, например, "Товары.Сумма"
// к виду: "ТоварыСумма".
//
// Параметры:
// 	ПутьКДанным - Строка - колонка имя которой необходимо нормализировать.
//
// Возвращаемое значение:
// 	Строка - нормализированное имя колонки.
//
Функция НормализироватьИмяКолонки(ПутьКДанным)
	
	ИмяКолонки = ПутьКДанным;
	ИмяКолонки = СтрЗаменить(ИмяКолонки, ".", "");
	ИмяКолонки = СтрЗаменить(ИмяКолонки, "'", "_");
	ИмяКолонки = СтрЗаменить(ИмяКолонки, "[", "_");
	ИмяКолонки = СтрЗаменить(ИмяКолонки, "]", "_");
	
	Пока Истина Цикл
		
		// 8.3.6+
		//Позиция = СтрНайти(ИмяКолонки, "" "");
		Позиция = Найти(ИмяКолонки, " ");
		Если Позиция = 0 Тогда
			Прервать;
		КонецЕсли;
		
		ИмяКолонки = Сред(ИмяКолонки, 1, Позиция - 1) + ВРег(Сред(ИмяКолонки, Позиция + 1, 1)) + 
			Сред(ИмяКолонки, Позиция + 2, СтрДлина(ИмяКолонки) - Позиция + 2);
		
	КонецЦикла;
		
	Возврат ИмяКолонки;
	
КонецФункции // НормализироватьИмяКолонки()

#КонецОбласти // СервисныеПроцедурыИФункции