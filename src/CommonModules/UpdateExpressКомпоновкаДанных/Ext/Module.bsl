// This file is part of Update.Express.
// Copyright © 2016 Petro Bazeliuk.
// 
// Update.Express is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as 
// published by the Free Software Foundation, either version 3 
// of the License, or any later version.
// 
// Update.Express is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public 
// License along with Update.Express. If not, see <http://www.gnu.org/licenses/>.

#Область ПрограммныйИнтерфейс

#Область ОперацииСхемыКомпоновкиДанных

Процедура УстановитьСхемуКомпоновкиДанных(АдресПриемник, АдресСхемаИсточник,
	ПроверятьНаИзменение = Ложь, БылиИзменения = Ложь) Экспорт
	
	Если ЭтоАдресВременногоХранилища(АдресСхемаИсточник) Тогда
		СхемаКомпоновкиДанных = ПолучитьИзВременногоХранилища(АдресСхемаИсточник);
	Иначе
		СхемаКомпоновкиДанных = АдресСхемаИсточник;
	КонецЕсли;
	
	Если ПроверятьНаИзменение Тогда
		
		БылиИзменения = Ложь;
		Если ЭтоАдресВременногоХранилища(АдресПриемник) Тогда
			
			ТекущаяСКД = ПолучитьИзВременногоХранилища(АдресПриемник);
			Если ТипЗнч(ТекущаяСКД) = Тип("СхемаКомпоновкиДанных") Тогда
				Если UpdateExpressСлужебный.ПолучитьXML(СхемаКомпоновкиДанных) <> 
					 UpdateExpressСлужебный.ПолучитьXML(ТекущаяСКД) Тогда	
					БылиИзменения = Истина;
				КонецЕсли
			Иначе
				БылиИзменения = Истина;
			КонецЕсли;
			
		Иначе
			БылиИзменения = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЭтоАдресВременногоХранилища(АдресПриемник) Тогда
		ПоместитьВоВременноеХранилище(СхемаКомпоновкиДанных, АдресПриемник);
	Иначе
		АдресПриемник = ПоместитьВоВременноеХранилище(СхемаКомпоновкиДанных, Новый УникальныйИдентификатор);
	КонецЕсли;
	
КонецПроцедуры // УстановитьСхемуКомпоновкиДанных()

Процедура СкопироватьСхемуКомпоновкиДанных(АдресПриемник, АдресИсточник) Экспорт
	
	СхемаКомпоновкиДанных = ПолучитьИзВременногоХранилища(АдресИсточник);	
	Если ТипЗнч(СхемаКомпоновкиДанных) = Тип("СхемаКомпоновкиДанных") Тогда
		СхемаКомпоновкиДанных = СериализаторXDTO.ПрочитатьXDTO(СериализаторXDTO.ЗаписатьXDTO(СхемаКомпоновкиДанных));
	Иначе
		СхемаКомпоновкиДанных = Новый СхемаКомпоновкиДанных;
	КонецЕсли;
	
	Если ЭтоАдресВременногоХранилища(АдресПриемник) Тогда
		ПоместитьВоВременноеХранилище(СхемаКомпоновкиДанных, АдресПриемник);
	Иначе
		АдресПриемник = ПоместитьВоВременноеХранилище(СхемаКомпоновкиДанных, Новый УникальныйИдентификатор);
	КонецЕсли;
	
КонецПроцедуры // СкопироватьСхемуКомпоновкиДанных()

// Процедура выполняет инициализацию компоновщика настроек.
//
// Параметры:
//	КомпоновщикНастроек 		  - КомпоновщикНастроекКомпоновкиДанных - компоновщик настроек компоновки данных.
//  АдресСхемыКомпоновкиДанных    - Строка                        		- адрес схемы компоновки данных.
//  АдресНастроекКомпоновкиДанных - Строка, Неопределено                - адрес настроек компоновки данных.
//
Процедура ИнициализироватьКомпоновщикНастроек(КомпоновщикНастроек, 
	АдресСхемыКомпоновкиДанных, 
	АдресНастроекКомпоновкиДанных = Неопределено) Экспорт
	
	Если ЭтоАдресВременногоХранилища(АдресСхемыКомпоновкиДанных) Тогда
		СхемаКомпоновкиДанных = ПолучитьИзВременногоХранилища(АдресСхемыКомпоновкиДанных);
	Иначе
		СхемаКомпоновкиДанных = АдресСхемыКомпоновкиДанных;	
	КонецЕсли;
	
	Если ЗначениеЗаполнено(АдресНастроекКомпоновкиДанных) Тогда
		Если ЭтоАдресВременногоХранилища(АдресНастроекКомпоновкиДанных) Тогда
			НастройкиКомпоновкиДанных = ПолучитьИзВременногоХранилища(АдресНастроекКомпоновкиДанных);
		Иначе
			НастройкиКомпоновкиДанных = АдресНастроекКомпоновкиДанных;	
		КонецЕсли;
	КонецЕсли;
	
	Попытка
		КомпоновщикНастроек.Инициализировать(
			Новый ИсточникДоступныхНастроекКомпоновкиДанных(АдресСхемыКомпоновкиДанных));
	Исключение
		UpdateExpressСлужебный.ЗаписатьВЖурналРегистрации(ОписаниеОшибки(), 
			УровеньЖурналаРегистрации.Ошибка);
	КонецПопытки;
	
	Если ЗначениеЗаполнено(АдресНастроекКомпоновкиДанных) Тогда
		КомпоновщикНастроек.ЗагрузитьНастройки(НастройкиКомпоновкиДанных);
	Иначе
		КомпоновщикНастроек.ЗагрузитьНастройки(СхемаКомпоновкиДанных.НастройкиПоУмолчанию);
	КонецЕсли;
	
	КомпоновщикНастроек.Восстановить(
		СпособВосстановленияНастроекКомпоновкиДанных.ПроверятьДоступность);
	
КонецПроцедуры // ИнициализироватьКомпоновщикНастроек

// Процедура устанавливает настройки компоновщика настроек из параметров запроса JSON. 
//
// Параметры:
//	КомпоновщикНастроек - КомпоновщикНастроекКомпоновкиДанных - компоновщик настроек компоновки данных.
//	ПараметрыЗапроса	- Структура							  - содержит параметры запроса JSON.
//
Процедура ОбработатьНастройкиКомпоновщикаНастроек(КомпоновщикНастроек,
	ПараметрыЗапроса) Экспорт
		
	Перем Настройки;
	
	Если ПараметрыЗапроса.Data.Свойство("Settings", Настройки) Тогда
		
		ПараметрыДанных = КомпоновщикНастроек.Настройки.ПараметрыДанных;
		ДоступныеПараметры = ПараметрыДанных.ДоступныеПараметры;
		
		// Проверка необходима так, как тип может быть Неопределено 
		ПараметрыИнициализированы = Ложь;
		Если ДоступныеПараметры <> Неопределено Тогда
			ПараметрыИнициализированы = 
				ТипЗнч(ДоступныеПараметры) = Тип("ДоступныеПараметрыКомпоновкиДанных");
		КонецЕсли;
				
		НастройкиИнициализированы = Ложь;
		Если ТипЗнч(Настройки) = Тип("Структура") Тогда
			НастройкиИнициализированы = Настройки.Количество() > 0; 
		КонецЕсли;
		
		Если ПараметрыИнициализированы И НастройкиИнициализированы Тогда
			ЗаполнитьКоллекциюЗначенийПараметровКомпоновкиДанных(
				ПараметрыДанных, Настройки);	
		КонецЕсли;
			
	КонецЕсли;
	
	//Если ПараметрыЗапроса.Data.Свойство("Filter", Настройки) Тогда
	//	
	//	ДоступныеПоляОтбора = КомпоновщикНастроек.Настройки.ДоступныеПоляОтбора;
	//	ДоступныеПараметры = ПараметрыДанных.ДоступныеПараметры;
	//	
	//	ПоляОтбораИнициализированы = Ложь;
	//	Если ДоступныеПоляОтбора <> Неопределено Тогда
	//		ПоляОтбораИнициализированы = 
	//			ТипЗнч(ДоступныеПараметры) = Тип("ДоступныеПараметрыКомпоновкиДанных");
	//	КонецЕсли;
	//			
	//	НастройкиИнициализированы = Ложь;
	//	Если ТипЗнч(Настройки) = Тип("Структура") Тогда
	//		НастройкиИнициализированы = Настройки.Количество() > 0; 
	//	КонецЕсли;
	//	
	//	Если ПараметрыИнициализированы И НастройкиИнициализированы Тогда
	//		ЗаполнитьКоллекциюЗначенийПараметровКомпоновкиДанных(
	//			ПараметрыДанных, Настройки);	
	//	КонецЕсли;
	//		
	//КонецЕсли;
		
КонецПроцедуры // ОбработатьНастройкиКомпоновщикаНастроек()


// Функция создает макет компоновки данных.
//
// Параметры:
//	СхемаКомпоновкиДанных     - СхемаКомпоновкиДанных     - схема, для которой требуется построить макет.
//	НастройкиКомпоновкиДанных - НастройкиКомпоновкиДанных - настройки, для которых необходимо создать макет.
//  ПараметрыМакета   		  - Структура - Параметры макета компоновки данных.
//		* Схема - СхемаКомпоновкиДанных - Схема, для которой требуется построить макет. 
//		* Настройки - НастройкиКомпоновкиДанных - Настройки, для которых необходимо создать макет. 
//		* ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных - Содержит переменную, в которую будут помещены данные
//        				      расшифровки. Если параметр не указан, расшифровка заполняться не будет.
//		* МакетОформления - МакетОформленияКомпоновкиДанных - Макет оформления, в соответствии с которым необходимо 
//                          оформлять макет компоновки данных. Если не указан, будет использоваться макет оформления 
//                          по умолчанию. 
//		* ТипГенератора - Тип - Указывает тип генератора макета компоновки данных.			  
//					  Возможные типы: 
//                    	ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений; 
//                      ГенераторМакетаКомпоновкиДанных.               
//					  Значение по умолчанию: 
//						Тип("ГенераторМакетаКомпоновкиДанных"). 
//		* ПроверятьДоступностьПолей - Булево - Определяет, выполнять ли проверку прав на просмотр полей и проверку 
//                                    доступности поля во включенных функциональных возможностях.
//		* ПараметрыФункциональныхОпций - Структура - Содержит параметры функциональных опций, используемые при 
//                                       исполнении отчета. 
//					
// Возвращаемое значение:
//	МакетКомпоновкиДанных - Созданный макет компоновки.	
//
Функция СоздатьМакетКомпоновкиДанных(ПараметрыМакета) Экспорт
	
	
	// TODO: Проверка параметров макета
	
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	Возврат КомпоновщикМакета.Выполнить(
		ПараметрыМакета.Схема, 
		ПараметрыМакета.Настройки, 
		ПараметрыМакета.ДанныеРасшифровки, 
		ПараметрыМакета.МакетОформления, 
		ПараметрыМакета.ТипГенератора,
		ПараметрыМакета.ПроверятьДоступностьПолей,
		ПараметрыМакета.ПараметрыФункциональныхОпций);
	
КонецФункции // СоздатьМакетКомпоновкиДанных() 

// Функция выводит результат схемы компоновки данных в дерево значений.
//
// Параметры:
//	ПараметрыВывода - Структура - параметры макета компоновки данных.
//		* ВнешниеНаборыДанных - Структура - ключ структуры соответствует имени внешнего набора данных. 
//                              Значение структуры - внешнему набору данных. 
//		* ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных - объект, в котором нужно заполнить данные расшифровки.
//                            Если не указан, то расшифровка заполняться не будет. 
//		* ВозможностьИспользованияВнешнихФункций - Булево - указывает возможность использования функции общих модулей
//                                                 конфигурации в выражениях компоновки данных.
//                                                 Значение по умолчанию: 
//													 Ложь.
//		* ПараметрыМакета - Структура - структура параметров необходимых для создания макета компоновки данных.
//			** Схема - СхемаКомпоновкиДанных - схема, для которой требуется построить макет. 
//			** Настройки - НастройкиКомпоновкиДанных - настройки, для которых необходимо создать макет. 
//			** ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных - содержит переменную, в которую будут помещены данные
//        				      расшифровки. Если параметр не указан, расшифровка заполняться не будет.
//			** МакетОформления - МакетОформленияКомпоновкиДанных - макет оформления, в соответствии с которым необходимо 
//                          оформлять макет компоновки данных. Если не указан, будет использоваться макет оформления 
//                          по умолчанию. 
//			** ТипГенератора - Тип - указывает тип генератора макета компоновки данных.			  
//					  Возможные типы: 
//                    	ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений; 
//                      ГенераторМакетаКомпоновкиДанных.               
//					  Значение по умолчанию: 
//						Тип("ГенераторМакетаКомпоновкиДанных"). 
//			** ПроверятьДоступностьПолей - Булево - определяет, выполнять ли проверку прав на просмотр полей и проверку 
//                                    доступности поля во включенных функциональных возможностях.
//			** ПараметрыФункциональныхОпций - Структура - содержит параметры функциональных опций, используемые при 
//                                       исполнении отчета.
//	ВозможностьПрерыванияПользователем - Булево - указывает, может ли пользователь прервать вывод при помощи комбинации
//										 клавиш Ctrl + Break.
//										 Значение по умолчанию: 
//										   Ложь. 	
//
// Возвращаемое значение:
//	ДеревоЗначений - Результат вывода схемы компоновки данных в дерево значений.	
//
Функция СформироватьРезультатДеревоЗначений(ПараметрыВывода, 
	ВозможностьПрерыванияПользователем = Ложь) Экспорт
	
	
	// TODO: Проверка параметров макета
	
	
	ПараметрыМакета = UpdateExpressСлужебныйКлиентСервер.СкопироватьСтруктуру(
		ПараметрыВывода.ПараметрыМакета); 	
		
	// Убедимся, что действительно верный тип генератора будет использован
	ПараметрыМакета.ТипГенератора = 
		Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений");		
	МакетКомпоновкиДанных = СоздатьМакетКомпоновкиДанных(ПараметрыМакета); 
	
	// Инициализировать процессор 
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновкиДанных, 
		ПараметрыВывода.ВнешниеНаборыДанных, 
		ПараметрыВывода.ДанныеРасшифровки, 
		ПараметрыВывода.ВозможностьИспользованияВнешнихФункций);

	// Вывести результат
	ДеревоЗначений = Новый ДеревоЗначений;
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;	
	ПроцессорВывода.УстановитьОбъект(ДеревоЗначений);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных, ВозможностьПрерыванияПользователем);
		
	Возврат ДеревоЗначений;
	
КонецФункции // СформироватьРезультатДеревоЗначений()

// Функция выводит результат схемы компоновки данных в табличный документ.
//
// Параметры:
//	ПараметрыВывода - Структура - параметры макета компоновки данных.
//		* ВнешниеНаборыДанных - Структура - ключ структуры соответствует имени внешнего набора данных. 
//                              Значение структуры - внешнему набору данных. 
//		* ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных - объект, в котором нужно заполнить данные расшифровки.
//                            Если не указан, то расшифровка заполняться не будет. 
//		* ВозможностьИспользованияВнешнихФункций - Булево - указывает возможность использования функции общих модулей
//                                                 конфигурации в выражениях компоновки данных.
//                                                 Значение по умолчанию: 
//													 Ложь.
//		* ПараметрыМакета - Структура - структура параметров необходимых для создания макета компоновки данных.
//			** Схема - СхемаКомпоновкиДанных - схема, для которой требуется построить макет. 
//			** Настройки - НастройкиКомпоновкиДанных - настройки, для которых необходимо создать макет. 
//			** ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных - содержит переменную, в которую будут помещены данные
//        				      расшифровки. Если параметр не указан, расшифровка заполняться не будет.
//			** МакетОформления - МакетОформленияКомпоновкиДанных - макет оформления, в соответствии с которым необходимо 
//                          оформлять макет компоновки данных. Если не указан, будет использоваться макет оформления 
//                          по умолчанию. 
//			** ТипГенератора - Тип - указывает тип генератора макета компоновки данных.			  
//					  Возможные типы: 
//                    	ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений; 
//                      ГенераторМакетаКомпоновкиДанных.               
//					  Значение по умолчанию: 
//						Тип("ГенераторМакетаКомпоновкиДанных"). 
//			** ПроверятьДоступностьПолей - Булево - определяет, выполнять ли проверку прав на просмотр полей и проверку 
//                                    доступности поля во включенных функциональных возможностях.
//			** ПараметрыФункциональныхОпций - Структура - содержит параметры функциональных опций, используемые при 
//                                       исполнении отчета.
//	ВозможностьПрерыванияПользователем - Булево - указывает, может ли пользователь прервать вывод при помощи комбинации
//										 клавиш Ctrl + Break.
//										 Значение по умолчанию: 
//										   Ложь.
//
// Возвращаемое значение:
//	ТабличныйДокумент - Результат вывода схемы компоновки данных в табличный документ.	
//
Функция СформироватьРезультатТабличныйДокумент(ПараметрыВывода, 
	ВозможностьПрерыванияПользователем = Ложь) Экспорт
	
	
	// TODO: Проверка параметров макета
	
		
	ПараметрыМакета = UpdateExpressСлужебныйКлиентСервер.СкопироватьСтруктуру(
		ПараметрыВывода.ПараметрыМакета);
		
	// Убедимся, что действительно верный тип генератора будет использован
	ПараметрыМакета.ТипГенератора = Тип("ГенераторМакетаКомпоновкиДанных");		
	МакетКомпоновкиДанных = СоздатьМакетКомпоновкиДанных(ПараметрыМакета);	
	
	// Инициализировать процессор 
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновкиДанных,
		ПараметрыВывода.ВнешниеНаборыДанных, 
		ПараметрыВывода.ДанныеРасшифровки, 
		ПараметрыВывода.ВозможностьИспользованияВнешнихФункций);

	// Вывести результат
	ТабличныйДокумент = Новый ТабличныйДокумент;
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	ПроцессорВывода.УстановитьДокумент(ТабличныйДокумент);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных, ВозможностьПрерыванияПользователем);
	
	Возврат ТабличныйДокумент;
	
КонецФункции // СформироватьРезультатТабличныйДокумент()


// Возвращает структуру параметров необходимых для создания макета компоновки данных.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Структура - Параметры макета компоновки данных.
//		* ВнешниеНаборыДанных - Структура - ключ структуры соответствует имени внешнего набора данных. 
//                              Значение структуры - внешнему набору данных. 
//		* ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных - объект, в котором нужно заполнить данные расшифровки.
//                            Если не указан, то расшифровка заполняться не будет. 
//		* ВозможностьИспользованияВнешнихФункций - Булево - указывает возможность использования функции общих модулей
//                                                 конфигурации в выражениях компоновки данных.
//                                                 Значение по умолчанию: 
//													 Ложь.
//		* ПараметрыМакета - Структура - структура параметров необходимых для создания макета компоновки данных.
//
Функция ПараметрыВыводаРезультатаКомпоновки() Экспорт
	
	ПараметрыВывода = Новый Структура;
	ПараметрыВывода.Вставить("ВнешниеНаборыДанных");
	ПараметрыВывода.Вставить("ДанныеРасшифровки");
	ПараметрыВывода.Вставить("ВозможностьИспользованияВнешнихФункций", Ложь);
	ПараметрыВывода.Вставить("ПараметрыМакета");
	Возврат ПараметрыВывода;
	
КонецФункции // ПараметрыВыводаРезультатаКомпоновки()

// Возвращает структуру параметров необходимых для создания макета компоновки данных.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Структура - Параметры макета компоновки данных.
//		* Схема - СхемаКомпоновкиДанных - схема, для которой требуется построить макет. 
//		* Настройки - НастройкиКомпоновкиДанных - настройки, для которых необходимо создать макет. 
//		* ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных - содержит переменную, в которую будут помещены данные
//        				      расшифровки. Если параметр не указан, расшифровка заполняться не будет.
//		* МакетОформления - МакетОформленияКомпоновкиДанных - макет оформления, в соответствии с которым необходимо 
//                          оформлять макет компоновки данных. Если не указан, будет использоваться макет оформления 
//                          по умолчанию. 
//		* ТипГенератора - Тип - указывает тип генератора макета компоновки данных.			  
//					  Возможные типы: 
//                    	ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений; 
//                      ГенераторМакетаКомпоновкиДанных.               
//					  Значение по умолчанию: 
//						Тип("ГенераторМакетаКомпоновкиДанных"). 
//		* ПроверятьДоступностьПолей - Булево - определяет, выполнять ли проверку прав на просмотр полей и проверку 
//                                    доступности поля во включенных функциональных возможностях.
//		* ПараметрыФункциональныхОпций - Структура - содержит параметры функциональных опций, используемые при 
//                                       исполнении отчета. 
//
Функция ПараметрыМакетаКомпоновкиДанных() Экспорт
	
	ПараметрыМакета = Новый Структура;
	ПараметрыМакета.Вставить("Схема");
	ПараметрыМакета.Вставить("Настройки");
	ПараметрыМакета.Вставить("ДанныеРасшифровки");
	ПараметрыМакета.Вставить("МакетОформления");
	ПараметрыМакета.Вставить("ТипГенератора", Тип("ГенераторМакетаКомпоновкиДанных"));
	ПараметрыМакета.Вставить("ПроверятьДоступностьПолей", Истина);
	ПараметрыМакета.Вставить("ПараметрыФункциональныхОпций");
	Возврат ПараметрыМакета;
	
КонецФункции // ПараметрыМакетаКомпоновкиДанных()

#КонецОбласти // ОперацииСхемыКомпоновкиДанных

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

#Область ОперацииСхемыКомпоновкиДанных

// Процедура заполняет значения параметров компоновки данных по настройкам из JSON-запроса.
//
// Параметры:
//	ПараметрыДанных - ЗначенияПараметровДанныхКомпоновкиДанных - Содержит значения параметров получения данных;
//  Настройки		- Структура 							   - Настройки прочитанные из JSON-запроса.
//
Процедура ЗаполнитьКоллекциюЗначенийПараметровКомпоновкиДанных(ПараметрыДанных, 
	Настройки)
	
	ДоступныеПараметры = ПараметрыДанных.ДоступныеПараметры;
	Для Каждого Настройка Из Настройки Цикл
		
		Параметр = Новый ПараметрКомпоновкиДанных(Настройка.Ключ);
		РезультатПоиска = ДоступныеПараметры.НайтиПараметр(Параметр);
		Если РезультатПоиска = Неопределено Тогда
			// TODO: Warning!
			Продолжить;
			
		КонецЕсли;
		
		// TODO: Это временное решение до полноценной поддержки агрегатных типов
		МассивТипов = РезультатПоиска.Тип.Типы();
		Если МассивТипов.Количество() = 1 Тогда
			
			ТипОпределен = Ложь;
			
			ТипЗначения = РезультатПоиска.Тип.Типы()[0];
			Если ТипЗначения = Тип("Строка") Тогда
				
				Значение = ПолучитьЗначениеСтроки(Настройка.Ключ, Настройка.Значение);
				ТипОпределен = Истина;
				
			ИначеЕсли ТипЗначения = Тип("СтандартныйПериод") Тогда
				
				Значение = ПолучитьЗначениеСтандартногоПериода(Настройка.Ключ, Настройка.Значение);
				ТипОпределен = Истина;
				
			Иначе
				
				ТипXML = XMLТип(ТипЗначения);
				Если ТипXML <> Неопределено Тогда
					
					ИмяТипаXML = ТипXML.ИмяТипа;
					Если UpdateExpressСлужебныйПовтИсп.ЭтоТипСправочникСсылка(ИмяТипаXML)
					 ИЛИ UpdateExpressСлужебныйПовтИсп.ЭтоТипДокументСсылка(ИмяТипаXML) 
					 ИЛИ UpdateExpressСлужебныйПовтИсп.ЭтоТипПланОбменаСсылка(ИмяТипаXML)
					 ИЛИ UpdateExpressСлужебныйПовтИсп.ЭтоТипПеречислениеСсылка(ИмяТипаXML)
					 ИЛИ UpdateExpressСлужебныйПовтИсп.ЭтоТипПланВидовХарактеристикСсылка(ИмяТипаXML)
					 ИЛИ UpdateExpressСлужебныйПовтИсп.ЭтоТипПланСчетовСсылка(ИмяТипаXML)
					 ИЛИ UpdateExpressСлужебныйПовтИсп.ЭтоТипПланВидовРасчетаСсылка(ИмяТипаXML)
					 ИЛИ UpdateExpressСлужебныйПовтИсп.ЭтоТипБизнесПроцессСсылка(ИмяТипаXML)
					 ИЛИ UpdateExpressСлужебныйПовтИсп.ЭтоТипЗадачаСсылка(ИмяТипаXML) Тогда
				
						Значение = ПолучитьЗначениеСсылки(Настройка.Ключ, 
							Настройка.Значение, ИмяТипаXML);
						ТипОпределен = Истина;
				
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			
							
			Если НЕ ТипОпределен Тогда
				
				ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
					// Сообщение об ошибке
					НСтр("en = 'For field [%1] type processing [%2] not implemented [CommonModule.UpdateExpressКомпоновкаДанных].'; 
						|ru = 'Для поля [%1] обработка Типа [%2] не реализована [ОбщийМодуль.UpdateExpressКомпоновкаДанных].'; 
						|uk = 'Для поля [%1] обробка Типу [%2] не реалізована [ОбщийМодуль.UpdateExpressКомпоновкаДанных].'"),		
						
					// Идентификатор поля в JSON
					Настройка.Ключ,
					
					// Тип значения доступного параметра СКД
					Строка(ТипЗначения));
					
			КонецЕсли;
			
			УстановитьЗначениеДоступногоПараметраКомпоновкиДанных(ПараметрыДанных, 
				Настройка.Ключ, Значение); 
			
		Иначе
				
			ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
				// Сообщение об ошибке
				НСтр("en = 'For field [%1] processing agregate Types not implemented [CommonModule.UpdateExpressКомпоновкаДанных].'; 
					|ru = 'Для поля [%1] обработка агрегатных Типов не реализована [ОбщийМодуль.UpdateExpressКомпоновкаДанных].'; 
					|uk = 'Для поля [%1] обробка агрегатних Типів не реалізована [ОбщийМодуль.UpdateExpressКомпоновкаДанных].'"),		
					
				// Идентификатор поля в JSON
				Настройка.Ключ);
				
		КонецЕсли;
		
	КонецЦикла;		
	
КонецПроцедуры // ЗаполнитьКоллекциюЗначенийПараметровКомпоновкиДанных()

// Процедура устанавливает значение параметров данных по идентификатору. 
//
// Параметры:
// 	ПараметрыДанных - ЗначенияПараметровДанныхКомпоновкиДанных - Содержит значения параметров получения данных;
//  Идентификатор   - Строка 	   - Идентификатор параметра;
//	Значение		- Произвольный - Значение параметра.
//
Процедура УстановитьЗначениеДоступногоПараметраКомпоновкиДанных(
	ПараметрыДанных, Идентификатор, Значение)
	
	Элементы = ПараметрыДанных.Элементы;	
	РезультатПоиска = Элементы.Найти(Идентификатор);
	Если РезультатПоиска <> Неопределено Тогда
		
		РезультатПоиска.Значение = Значение;
		
	Иначе
		// TODO: Пока не известно нужно ли доделывать
		//НовыйЭлемент = Элементы.Добавить();
		
		ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
			// Сообщение об ошибке
			НСтр("en = 'For field [%1] adding new elements into DataCompositionParameterValueCollection not implemented.'; 
				|ru = 'Для поля [%1] добавление новых элементов в КоллекцияЗначенийПараметровКомпоновкиДанных не реализовано.'; 
				|uk = 'Для поля [%1] додавання нових елементів в КоллекцияЗначенийПараметровКомпоновкиДанных не реалізовано.'"),		
				
			// Идентификатор поля в JSON
			Идентификатор);
		
	КонецЕсли;
	
КонецПроцедуры // УстановитьЗначениеДоступногоПараметраКомпоновкиДанных()

#КонецОбласти // ОперацииСхемыКомпоновкиДанных

#Область ОперацииПреобразованияЗначений

// Процедура проверяет на соответствие типа ожидаемому. 
//
// Параметры:
//	Идентификатор - Строка		 - Имя колонки;
//	Значение 	  - Произвольный - Значение для проверки на соответствие типа;
//  ОжидаемыйТип  - Строка 		 - Строчное наименование ожидаемого типа.
//
Процедура ВыполнитьПроверкуНаСоответствиеТипа(Знач Идентификатор, Значение, ОжидаемыйТип)
	
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗначения <> Тип(ОжидаемыйТип) Тогда
		
		ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
			// Сообщение об ошибке
			НСтр("en = '[%1] Expected type [%2] and received type is [%3].'; 
				|ru = '[%1] Ожидался тип [%2], а получили тип [%3].'; 
				|uk = '[%1] Очікувався тип [%2], але отримали тип [%3].'"),		
				
			// Идентификатор поля в JSON
			Идентификатор,
			
			// Строчное представление ожидаемого типа
			ОжидаемыйТип,
			
			// Строчное представление полученного типа
			Строка(ТипЗначения));
 
	КонецЕсли;
	
КонецПроцедуры // ВыполнитьПроверкуНаСоответствиеТипа() 

// Процедура проверяет, может ли значение переменной интерпретироваться как УникальныйИдентификатор. 
//
// Параметры:
//	Идентификатор - Строка		 - Имя колонки;
//	Значение 	  - Произвольный - Значение которое необходимо проверить.
//
Процедура ВыполнитьПроверкуУникальногоИдентификатора(Знач Идентификатор, Значение)
	
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗнч(Значение) <> Тип("Строка") Тогда
		
		ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
			// Сообщение об ошибке
			НСтр("en = 'In the field [%1] guid expected type [String] and received type is [%2].'; 
				|ru = 'В поле [%1] уникальный идентификатор ожидался тип [Строка], а получили тип [%2].'; 
				|uk = 'В полі [%1] унікальний ідентифікатор очікувався тип [Строка], але отримали тип [%2].'"),		
				
			// Идентификатор поля в JSON
			Идентификатор,
			
			// Строчное представление ожидаемого типа
			Строка(ТипЗначения));
		
	КонецЕсли;
		
	Если ПустаяСтрока(Значение) Тогда
		
		ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
			// Сообщение об ошибке
			НСтр("en = 'In the field [%1] guid cannot be empty.'; 
				|ru = 'В поле [%1] уникальный идентификатор не может быть пустым.'; 
				|uk = 'В полі [%1] унікальний ідентифікатор не може бути порожнім.'"),		
				
			// Идентификатор поля в JSON
			Идентификатор);
			
	КонецЕсли;
	
	Если СтрДлина(СокрЛП(Значение)) <> 36 Тогда
		
		ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
			// Сообщение об ошибке
			НСтр("en = 'In the field [%1] guid must be 36 symbols long.'; 
				|ru = 'В поле [%1] уникальный идентификатор должен иметь длину 36 символов.'; 
				|uk = 'В полі [%1] унікальний ідентифікатор повинен мати довжину 36 символів.'"),		
				
			// Идентификатор поля в JSON
			Идентификатор);
			
	КонецЕсли;
	
КонецПроцедуры // ВыполнитьПроверкуУникальногоИдентификатора()

// Процедура проверяет, может ли значение переменной интерпретироваться как код объекта конфигурации. 
//
// Параметры:
//	Идентификатор - Строка		 - Имя колонки;
//	Значение 	  - Произвольный - Значение которое необходимо проверить;
//  ИмяТипаXML 	  - Строка		 - Имя типа XML объекта конфигурации.
//
Процедура ВыполнитьПроверкуКодаОбъектаКонфигурации(Знач Идентификатор, Значение, 
	ИмяТипаXML)
	
	ТипЗначения = ТипЗнч(Значение);
	СвойстваОбъектов = Метаданные.СвойстваОбъектов;
	МетаданныеОбъекта = Метаданные.НайтиПоТипу(Тип(ИмяТипаXML));
	
	Если МетаданныеОбъекта = Неопределено Тогда
		
		ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
			// Сообщение об ошибке
			НСтр("en = 'The field [%1] has unexpected type [%2].'; 
				|ru = 'Поле [%1] Имеет неожиданный тип [%2].'; 
				|uk = 'Поле [%1] Має неочікуваний тип [%2].'"),		
				
			// Идентификатор поля в JSON
			Идентификатор,
			
			// Имя типа XML идентификатора
			ИмяТипаXML);
		
	КонецЕсли;
	
	
	Если UpdateExpressСлужебныйПовтИсп.ЭтоТипСправочникСсылка(ИмяТипаXML) Тогда
		
		Если МетаданныеОбъекта.ДлинаКода = 0 Тогда
		
			ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
					
				// Сообщение об ошибке
				НСтр("en = 'The field [%1] Code in configuration has zero length.'; 
					|ru = 'Поле [%1] длина поля Код в конфигурации равна нулю.'; 
					|uk = 'Поле [%1] довжина поля Код в конфігурації рівна нулю.'"),		
					
				// Идентификатор поля в JSON
				Идентификатор);
				
		КонецЕсли;
	
	
		ТипКода = МетаданныеОбъекта.ТипКода;
		Если ТипКода = СвойстваОбъектов.ТипКодаСправочника.Строка Тогда
			
			Если ТипЗначения <> Тип("Строка") Тогда 
				
				ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
					// Сообщение об ошибке
					НСтр("en = 'In the field [%1] expected Code type [%2] and received type is [%3].'; 
						|ru = 'В поле [%1] тип Кода ожидался [%2], а получили тип [%3].'; 
						|uk = 'В полі [%1] тип Коду очікувався [%2], але отримали тип [%3].'"),		
						
					// Идентификатор поля в JSON
					Идентификатор,
					
					// Строчное представление ожидаемого типа
					"Строка",
					
					// Строчное представление полученного типа
					Строка(ТипЗначения));
								
			КонецЕсли;
			
		ИначеЕсли ТипКода = СвойстваОбъектов.ТипКодаСправочника.Число Тогда
			
			Если ТипЗначения <> Тип("Число") Тогда
				
				ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
					// Сообщение об ошибке
					НСтр("en = 'In the field [%1] expected Code type [%2] and received type is [%3].'; 
						|ru = 'В поле [%1] тип Кода ожидался [%2], а получили тип [%3].'; 
						|uk = 'В полі [%1] тип Коду очікувався [%2], але отримали тип [%3].'"),		
						
					// Идентификатор поля в JSON
					Идентификатор,
					
					// Строчное представление ожидаемого типа
					"Число",
					
					// Строчное представление полученного типа
					Строка(ТипЗначения));
				
			КонецЕсли;
			
		Иначе
			
			ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
				// Сообщение об ошибке
				НСтр("en = 'In the field [%1] Code type [%2] not supported.'; 
					|ru = 'В поле [%1] тип Кода [%2] не поддерживается.'; 
					|uk = 'В полі [%1] тип Коду [%2] не підтримується.'"),		
					
				// Идентификатор поля в JSON
				Идентификатор,
				
				// Строчное представление не поддерживаемого типа кода
				Строка(ТипКода));
			
		КонецЕсли;
			
		Если ТипЗначения = Тип("Число") Тогда
			ДлиннаКода = СтрДлина(Формат(Значение, "ЧГ=0"));		
		Иначе
			ДлиннаКода = СтрДлина(СокрЛП(Значение));	
		КонецЕсли;
		
		Если МетаданныеОбъекта.ДлинаКода < ДлиннаКода Тогда
			
			ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
					
				// Сообщение об ошибке
				НСтр("en = 'In the field [%1] Code lenght is [%2] and maximum length is [%3].'; 
					|ru = 'В поле [%1] длина Кода равна [%2], что больше максимальной длины [%3].'; 
					|uk = 'В полі [%1] довжина Коду рівна [%2], що більше максимальної [%3].'"),		
					
				// Идентификатор поля в JSON
				Идентификатор,
				
				// Длина кода в поле JSON
				ДлиннаКода,
				
				// Длина кода в метаданных конфигурации
				МетаданныеОбъекта.ДлинаКода);
							
		КонецЕсли;
			
	Иначе
			
		ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
			// Сообщение об ошибке
			НСтр("en = 'Field [%1] Code in [%2] is not supported in configuration.'; 
				|ru = 'Поле [%1] Код в [%2] не поддерживается в конфигурации.'; 
				|uk = 'Поле [%1] Код в [%2] не підтримується в конфігурації.'"),		
				
			// Идентификатор поля в JSON
			Идентификатор,
			
			// Строчное представление типа в котором не поддерживает поле код
			ИмяТипаXML);		
						
	КонецЕсли;
		
КонецПроцедуры // ВыполнитьПроверкуКодаОбъектаКонфигурации()






// Выполняет преобразование значения в значение типа которое указано в параметре ИмяТипаXML.
//
// Параметры:
//	Идентификатор     - Строка	  - Имя колонки в JSON;
//	Значение 	      - Структура - Значение которое необходимо преобразовать к типу ИмяТипаXML;
//	ИмяТипаXML        - Строка	  - Имя типа XML к которому необходимо преобразовать Значение.
//
// Возвращаемое значение:
//	ОбъектСсылка - Преобразованное значение.
//
Функция ПолучитьЗначениеСсылки(Знач Идентификатор, Значение, ИмяТипаXML)
	
	Перем УникальныйИдентификатор, Код, Номер, Наименование;
	
	ВыполнитьПроверкуНаСоответствиеТипа(Идентификатор, Значение, "Структура");
		
	ОбщийМенеджерОбъекта = UpdateExpressСлужебный
		.ПолучитьМенеджерОбъектаПоИмениТипаXML(ИмяТипаXML);	
	Если ОбщийМенеджерОбъекта = Неопределено Тогда
		
		ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
			// Сообщение об ошибке
			НСтр("en = 'Field [%1] unable to indetify object manager for [%2].'; 
				|ru = 'Поле [%1] не удалось идетифицировать менеджер объекта для [%2].'; 
				|uk = 'Поле [%1] не вдалось ідентифікувати менеджер об''єкту для [%2].'"),		
				
			// Идентификатор поля в JSON
			Идентификатор,
			
			// Тип объекта конфигурации элемент которого не удалось найти
			ИмяТипаXML);

	КонецЕсли;
	
	ИмяОбъекта = ПолучитьИмяОбъектаКонфигурации(Идентификатор, ИмяТипаXML);
	МенеджерОбъекта = ОбщийМенеджерОбъекта[ИмяОбъекта];
	
	
	// Поиск объекта по уникальному идентификатору
	Если Значение.Свойство("Guid", УникальныйИдентификатор)
	 ИЛИ Значение.Свойство("УникальныйИдентификатор", УникальныйИдентификатор) Тогда
		
		ВыполнитьПроверкуУникальногоИдентификатора(Идентификатор, 
			УникальныйИдентификатор);
		
		ОбъектСсылка = МенеджерОбъекта.ПолучитьСсылку(Новый УникальныйИдентификатор(
			УникальныйИдентификатор));
			
		Если ПустаяСтрока(ОбъектСсылка.ВерсияДанных) Тогда

			ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
				// Сообщение об ошибке
				НСтр("en = 'Field [%1] unable to find [%2] with guid [%3].'; 
					|ru = 'Поле [%1] не удалось найти [%2] c уникальным идентификатором [%3].'; 
					|uk = 'Поле [%1] не вдалось знайти [%2] з унікальним ідентифікатором [%3].'"),		
					
				// Идентификатор поля в JSON
				Идентификатор,
				
				// Тип объекта конфигурации элемент которого не удалось найти
				ИмяТипаXML,
				
				// Уникальный идентификатор в поле JSON
				УникальныйИдентификатор);

		КонецЕсли;
		
		Возврат ОбъектСсылка;
			
	КонецЕсли;
	
	
	// Поиск объекта по коду	
	Если Значение.Свойство("Code", Код)
	 ИЛИ Значение.Свойство("Код", Код) Тогда
		
		ВыполнитьПроверкуКодаОбъектаКонфигурации(Идентификатор, Код, 
			ИмяТипаXML);
			
		ОбъектСсылка = МенеджерОбъекта.НайтиПоКоду(Код);
		
		Если ОбъектСсылка.Пустая() Тогда
			
			ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
				// Сообщение об ошибке
				НСтр("en = 'The field [%1] unable to find [%2] with Code [%3].'; 
					|ru = 'Поле [%1] не удалось найти [%2] c Кодом [%3].'; 
					|uk = 'Поле [%1] не вдалось знайти [%2] з Кодом [%3].'"),		
					
				// Идентификатор поля в JSON
				Идентификатор,
				
				// Тип объекта конфигурации элемент которого не удалось найти
				ИмяТипаXML,
				
				// Код в поле JSON
				Код);
			
		КонецЕсли;
		
		Возврат ОбъектСсылка;
				
	КонецЕсли;
	
	
	// Поиск объекта по номеру	
	Если Значение.Свойство("Number", Номер)
	 ИЛИ Значение.Свойство("Номер", Номер) Тогда
		ВызватьИсключение "TODO: Number";		
	КонецЕсли;
		
	
	// Поиск по наименованию
	Если Значение.Свойство("Description", Наименование)
	 ИЛИ Значение.Свойство("Наименование", Наименование) Тогда
		ВызватьИсключение "TODO: Description";		
	КонецЕсли;

			
	ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
		// Сообщение об ошибке
		НСтр("en = 'The field [%1] unable to find [%2].'; 
			|ru = 'Поле [%1] не удалось найти [%2].'; 
			|uk = 'Поле [%1] не вдалось знайти [%2].'"),		
			
		// Идентификатор поля в JSON
		Идентификатор,
		
		// Тип объекта конфигурации элемент которого не удалось найти
		ИмяТипаXML);
	
КонецФункции // ПолучитьЗначениеСсылки()

// Выполняет преобразование значение в значение типа "Строка".
//
// Параметры:
//  Идентификатор - Строка	     - Имя колонки;
//	Значение 	  - Произвольный - Значение которое необходимо преобразовать к типу "Строка". 
//
// Возвращаемое значение:
//	Строка - Преобразованное значение.
//
Функция ПолучитьЗначениеСтроки(Знач Идентификатор, Значение)
	
	ВыполнитьПроверкуНаСоответствиеТипа(Идентификатор, Значение, "Строка");
					
	Возврат Значение;
	
КонецФункции // ПолучитьЗначениеСтроки()

// Выполняет преобразование значения в значение типа "СтандартныйПериод".
//
// Параметры:
//  Идентификатор - Строка	  - Имя колонки;
//	Значение 	  - Структура - Значение которое необходимо преобразовать к типу "Структура".
//
// Возвращаемое значение:
//	СтандартныйПериод - Преобразованное значение.
//
Функция ПолучитьЗначениеСтандартногоПериода(Знач Идентификатор, Значение)
	
	Перем ДатаНачала, ДатаОкончания, Вариант;
	
	ВыполнитьПроверкуНаСоответствиеТипа(Идентификатор, Значение, "Структура");
	
	
	ЕстьВариант = Значение.Свойство("Variant", Вариант)
		ИЛИ Значение.Свойство("Вариант", Вариант);
		
	ЕстьДатаНачала = Значение.Свойство("StartDate", ДатаНачала)
		ИЛИ Значение.Свойство("ДатаНачала", ДатаНачала);
				   
	ЕстьДатаОкончания = Значение.Свойство("EndDate", ДатаОкончания)
		ИЛИ Значение.Свойство("ДатаОкончания", ДатаОкончания);
		
	Если ЕстьДатаНачала И ЕстьДатаОкончания Тогда
		
		СтандартныйПериод = Новый СтандартныйПериод;		
		СтандартныйПериод.ДатаНачала = ПолучитьДату(ДатаНачала);
		СтандартныйПериод.ДатаОкончания = ПолучитьДату(ДатаОкончания);		
		Если СтандартныйПериод.ДатаНачала <= СтандартныйПериод.ДатаОкончания Тогда
			Возврат СтандартныйПериод;	
		Иначе
			СообщениеОбОшибке = НСтр(
				"en = '[%1][StartDate] is greater than [EndDate].'; 
				|ru = '[%1][ДатаНачала] не может быть больше [ДатаОкончания].'; 
				|uk = '[%1][ДатаНачала] не може бути більшою [ДатаОкончания].'");
			СообщениеОбОшибке = UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				СообщениеОбОшибке, Идентификатор);		
			ВызватьИсключение СообщениеОбОшибке;		
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЕстьВариант Тогда
		Возврат Новый СтандартныйПериод(ВариантСтандартногоПериода[Вариант]);	
	КонецЕсли;
	
	СообщениеОбОшибке = НСтр(
		"en = '[%1]Unable to parse [StandardPeriod] ([StartDate] and [EndDate] or [Variant] not found).'; 
		|ru = '[%1]Не удалось распознать [СтандартныйПериод] ([ДатаНачала] и [ДатаОкончания] или [Вариант] не найдены).'; 
		|uk = '[%1]Не вдалось розпізнати [СтандартныйПериод] ([ДатаНачала] и [ДатаОкончания] или [Вариант] не найдены).'");
	СообщениеОбОшибке = UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
		СообщениеОбОшибке, Идентификатор);
	ВызватьИсключение СообщениеОбОшибке;
		   	
КонецФункции // ПолучитьЗначениеСтандартногоПериода()



// Выполняет преобразование строки, прочитанной в JSON-формате, в значение типа Дата.
//
// Параметры:
// 	Строка - Строка - Строка, которую требуется преобразовать в дату.
//
// Возвращаемое значение:
// 	Дата - Преобразованное значение.	
//
Функция ПолучитьДату(Строка)
	
	Перем ПреобразованнаяДата;
	
	Если ПолучитьДатуПоФормату(Строка, ФорматДатыJSON.ISO, ПреобразованнаяДата) Тогда
		Возврат ПреобразованнаяДата;	
	КонецЕсли;
	
	Если ПолучитьДатуПоФормату(Строка, ФорматДатыJSON.JavaScript, ПреобразованнаяДата) Тогда
		Возврат ПреобразованнаяДата;	
	КонецЕсли;
	
	Если ПолучитьДатуПоФормату(Строка, ФорматДатыJSON.Microsoft, ПреобразованнаяДата) Тогда
		Возврат ПреобразованнаяДата;	
	КонецЕсли;
	
	Возврат Дата(Строка);
	
КонецФункции // ПолучитьДату()

// Выполняет преобразование строки, прочитанной в JSON-формате, в значение типа Дата.
//
// Параметры:
//	Строка 				- Строка         - Строка, которую требуется преобразовать в дату; 
//	Формат 				- ФорматДатыJSON - Формат, в котором представлена дата в строке, подлежащей преобразованию;
//  ПреобразованнаяДата - Неопределено   - В эту переменную будет помещен результат преобразования в случае успеха.
//
// Возвращаемое значение:
// 	Булево - Истина - Преобразование успешно выполнено; Ложь - в противном случае.
//
Функция ПолучитьДатуПоФормату(Знач Строка, Формат, ПреобразованнаяДата)
	
	Попытка
		 ПреобразованнаяДата = ПрочитатьДатуJSON(Строка, Формат);
	Исключение
		Возврат Ложь;	 
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции // ПолучитьДатуПоФормату()

// Выполняет поиск ссылки по коду и возвращает ссылку.
//
// Параметры:
// 	Строка - Число, Строка - Строка, которую требуется преобразовать в дату.
//
// Возвращаемое значение:
// 	Дата - Преобразованное значение.	
//
Функция ПолучитьСсылкуПоКоду(Знач Код)
	
	
	
КонецФункции // ПолучитьСсылкуПоКоду()



// Выполняет получение имя объекта конфигурации по его типу.
//
// Параметры:
//  Идентификатор - Строка - Имя колонки;
//	ИмяТипаXML    - Строка - Имя типа XML объекта конфигурации.
//
// Возвращаемое значение:
//  Строка - Имя объекта конфигурации.
//
Функция ПолучитьИмяОбъектаКонфигурации(Знач Идентификатор, ИмяТипаXML) 
	
	МетаданныеОбъекта = Метаданные.НайтиПоТипу(Тип(ИмяТипаXML));
	Если МетаданныеОбъекта = Неопределено Тогда
		
		ВызватьИсключение UpdateExpressСлужебный.ПодставитьПараметрыВСтроку(
				
			// Сообщение об ошибке
			НСтр("en = 'The field [%1] has unexpected type [%2].'; 
				|ru = 'Поле [%1] Имеет неожиданный тип [%2].'; 
				|uk = 'Поле [%1] Має неочікуваний тип [%2].'"),		
				
			// Идентификатор поля в JSON
			Идентификатор,
			
			// Имя типа XML идентификатора
			ИмяТипаXML);
		
	КонецЕсли;
	
	Возврат МетаданныеОбъекта.Имя;
	
КонецФункции // ПолучитьИмяОбъектаКонфигурации()

#КонецОбласти // ОперацииПреобразованияЗначений

#Область ОперацииОбработкиКоллекцийЗначений

// Только для внутреннего использования
//Процедура ЗаполнитьСтруктуруОбменаПоГруппировкам(СтруктураОбмена, 
//	КоллекцияЗначений, Ключ = "Data", КлючиСтруктуры = Неопределено)
//	
//	Если КлючиСтруктуры = Неопределено Тогда
//		КлючиСтруктуры = КоллекцияЗначений.Колонки;
//		Если КлючиСтруктуры.Количество() = 0 Тогда
//			Возврат;
//		КонецЕсли;		
//	КонецЕсли;
//	
//	ТипНеопределено = Тип("Неопределено");
//	Для каждого Строка Из КоллекцияЗначений.Строки Цикл
//		
//		Структура = Новый Структура;
//		Для каждого Колонка Из КлючиСтруктуры Цикл
//			Значение = Строка[Колонка.Имя];
//			Если ТипЗнч(Значение) <> ТипНеопределено Тогда
//				Структура.Вставить(Колонка.Имя, Значение); 			
//			КонецЕсли;
//		КонецЦикла;
//		
//		Если Строка.Строки.Количество() > 0 Тогда
//			Структура.Вставить("Rows", Новый Массив);	
//			ЗаполнитьСтруктуруОбменаПоГруппировкам(
//				Структура, Строка, "Rows", КлючиСтруктуры);
//		КонецЕсли;
//		
//		СтруктураОбмена[Ключ].Добавить(Структура);
//		
//	КонецЦикла;
//	
//КонецПроцедуры // ЗаполнитьСтруктуруОбменаПоГруппировкам()

// Только для внутреннего использования
//Процедура ЗаполнитьСтруктуруОбменаДетальныеЗаписи(СтруктураОбмена, 
//	КоллекцияЗначений, Ключ = "Data", КлючиСтруктуры = Неопределено)
//	
//	Если КлючиСтруктуры = Неопределено Тогда
//		
//		Колонки = КоллекцияЗначений.Колонки;
//		Если Колонки.Количество() = 0 Тогда
//			Возврат;
//		КонецЕсли;
//		
//		КлючиСтруктуры = "";
//		Для Каждого Колонка Из Колонки Цикл
//			Если ПустаяСтрока(КлючиСтруктуры) Тогда
//				КлючиСтруктуры = Колонка.Имя;	
//			Иначе
//				КлючиСтруктуры = КлючиСтруктуры + "," + Колонка.Имя;	
//			КонецЕсли;		
//		КонецЦикла;
//		
//	КонецЕсли;
//		
//	Для Каждого Строка Из КоллекцияЗначений.Строки Цикл
//		
//		Структура = Новый Структура(КлючиСтруктуры);	
//		ЗаполнитьЗначенияСвойств(Структура, Строка);
//		
//		Если Строка.Строки.Количество() > 0 Тогда
//			Структура.Вставить("Rows", Новый Массив);	
//			ЗаполнитьСтруктуруОбменаДетальныеЗаписи(
//				Структура, Строка, "Rows", КлючиСтруктуры);
//		КонецЕсли;
//			
//		СтруктураОбмена[Ключ].Добавить(Структура); 
//		
//	КонецЦикла;
//	
//КонецПроцедуры // ЗаполнитьСтруктуруОбменаДетальныеЗаписи()

#КонецОбласти // ОперацииОбработкиКоллекцийЗначений

#КонецОбласти // СлужебныеПроцедурыИФункции